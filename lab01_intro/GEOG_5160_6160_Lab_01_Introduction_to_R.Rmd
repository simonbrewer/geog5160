---
title: "GEOG 5160 6160 Lab 01 Introduction to R"
author: | 
  | Simon Brewer
  | Geography Department
  | University of Utah
date: "December 30, 2020"
output:
  html_document:
    toc: true
    toc_float: true
    fig_caption: true
---

## Introduction

This is an optional lab that will give you a brief introduction to R. If you haven't used R before, I would **highly** recommend completing this. We will be using R throughout the semester and you will find it useful to have some knowledge of how it works. This lab requires a file containing a set of morphological measurements on plants *iris.csv*, which is available through Canvas. 

### A quick note on formatting

In this and subsequent labs, code that can be entered into R will be high-lit, e.g.:

```{r eval=FALSE}
plot(x, y)
```

And R output will be formatted with `##` at the start of the line. File names will be given in *italics* and will be available in the 'Datafiles' directory on the course Canvas site. 

### Getting started

#### RStudio layout
The R Studio interface consists of several windows. Start R Studio from the 'Start' menu under Windows, and the following window should appear:

![RStudio Interface](./images/rstudio.png)

- Bottom left: console window (also called command window). Here you can type simple commands after the `>` prompt and R will then execute your command. This is the most important window, because this is where R actually does stuff.
- Top left: editor window (also called script window). Collections of commands (scripts) can be edited and saved. When you don't see this window, you can open it with [File $>$ New $>$ R script]. Just typing a command in the editor window is not enough, it has to get into the command window before R executes the command. If you want to run a line from the script window (or the whole script), copy and paste it to the console. Alternatively, you can click [Run] or press CTRL+ENTER to send it to the command window.
- Top right: workspace / history window. In the workspace window you can see which data and values R has in its memory. You can view and edit the values by clicking on them. The history window shows what has been typed before.
- Bottom right: Files / plots / packages / help window. Here you can open files, view plots (also previous plots), install and load packages or use the help function. You can change the size of the windows by dragging the grey bars between the windows.

#### Working with R
Much of your time spent with R will involve typing commands in at the console, and R Studio has some help with this.

- The up/down arrow keys allow you to cycle back through commands that have been previously entered. You can then modify or reuse these as necessary. The commands can also be accessed through the `History' tab in the top-right panel
- The console has 'tab-completion', which allows you to enter the first few characters of a string or function name, press 'Tab', and R Studio will bring up a list of possible options that match the string you entered. Try typing `pri` and pressing 'Tab' - you should see `print` as part of the list, and you can click on this, or scroll down to use it from the list. 

#### Workspace
R has a *workspace* where variables and data are stored as you use it. This is held in the memory of the computer, so if you are working from a file, you will need to read it in to the R workspace, and then work on the values held in memory. This means that you only access files to read in or write out data, the rest of the time you are working on a copy in the workspace. 

#### Working directory
R defines the working directory as the folder in which it is currently working. When you ask R to open a certain file, it will look in the working directory for this file, and when you tell R to save a data file or plot, it will save it in the working directory.

Before you do anything in R, it is important to set your working directory to where all your data and script files are or should be stored. Create a directory on the computer you are currently working on, or on a USB drive. Now change to this directory, either by typing `setwd("directoryname")` in the command window. For example:

```{r eval=FALSE}
setwd("N:/Rintro/Data/")
```

Make sure that the slashes are forward slashes and that you don't forget the apostrophes. R is case sensitive, so make sure you write capitals where necessary. 

Alternatively, you can open a browser to help select the working directory by going to [Session] $>$ [Change working directory]. If you are using the base version of R, go to [File] $>$ [Change dir...] in Windows, or [Misc] $>$ [Change Working Directory] in Mac. 

#### Using the console
In the console, the '`>`' is the prompt, and your commands will be entered here. Click on the console window, then enter the following:
```{r}
2+2
```

And press 'Enter', and R will tell you, not too surprisingly, that 2+2=4. The spacing is not relevant, you could equally enter `2 + 2` or `2+ 2` and get the same result. The `[1]` before the output is a vector index. It refers to the first value in the vector (here a vector of length 1). We'll be using this later.

We can equally use standard math functions, for example, to take the natural log or square root of 2:
```{r}
log(2)
sqrt(2)
```

## Working with variables in R

While R works perfectly well as a calculator, the real power comes when you start to use variables. These allow you to store the output of a calculation and then re-use this. To store the output of one of the functions we used above, simply provide a name for the variable (here, we'll call this `myresult`) and use the assignment operator `<-` or `=` to store the output:

```{r}
myresult <- log(2)
```

If you look at the [Environment] tab in the top right hand window, you should now see that R has created this variable, with a value of approximately `r round(log(2), 4)`. 

### Reading in data

Larger data sets will most commonly be read in from files. R can use many different file types, but csv files are recommended as the easiest way to transfer between R and Excel. Start by downloading the file *iris.csv* from Canvas, and copy this to your working directory. Make sure that you have correctly set this as your working directory by typing:

```{r echo=TRUE, results='hide'}
getwd()
```

Now get a list of files as follows (note the use of the pattern parameter to get only certain files):

```{r results='hide'}
list.files(pattern=".csv")
```

Use the `read.csv()` function to read in the data from the Iris data file, and store it in a variable called `iris`:
```{r}
iris <- read.csv("iris.csv")
```

The data are stored in a *data frame*, which consists of a set of rows and columns, much like a spreadsheet. To print out contents of this data frame (or any variable stored in R), simply type the name of that variable at the command prompt. Other useful commands are `class()` to see what data class a variable is, and `names()` to get a list of the column headers. The function `str()` is probably the most useful, describing the column names and the type of data stored in them.
```{r results='hide'}
iris
class(iris)
names(iris)
str(iris)
```

The variable 'iris' here represents the whole data frame. If you want to access subsets of the data frame or individual values, you will need to understand indexes in R. There are two main method to access parts of a data frame, the `$` notation, and row/column indexes. The `$` notation allows you to access individual columns:

```{r results='hide'}
iris$Sepal.Length  	# Extract single column
```

The row/column notation is a more flexible approach, and allows you to access individual rows, columns or values, or to access a range of rows and columns

```{r results='hide'}
iris[ ,4]   # 4th column
iris[10, ]  # 10th row
```

Alternatively, you can access a range of rows and columns using `:`:

```{r results='hide'}
iris[ ,1:4]     # Columns 1 to 4
iris[1:10, ]    # First 10 rows
iris[1:50,1:2]  # First 50 rows of the first two columns
```

Note that the data frame can contain different data classes. Compare:
```{r}
class(iris)			
class(iris$Sepal.Length)		
class(iris$Species)			
```

The last of these should tell you that `class(iris$Species)` is a factor. This is how R describes categorical variables, here the name of individual plant species.

To access specific values within a vector, use the index of that value:
```{r results='hide'}
iris$Sepal.Length[3]      # 3rd element
iris$Sepal.Length[-3]     # All but 3rd element
iris$Sepal.Length[1:10]   # First 10 elements
```

Logical operators $<, <=, >, >=, ==, !=$ can be used to select parts of the data set by value. This is very useful if you only want to analyze part of your dataset
```{r results='hide'}
iris$Sepal.Length[iris$Sepal.Length > 5]	# All over 5 
iris[iris$Sepal.Length > 5, ]	# All columns with sepal length over 5 
iris$Sepal.Length[(iris$Species == 'setosa')] 	# All "setosa" species
iris[(iris$Species == 'setosa'), ] 	# All columns for "setosa" species
```

These operators can be combined, so to get all instances of "setosa" species with sepal lengths greater than 5:

```{r results='hide'}
iris[(iris$Species == 'setosa') & (iris$Sepal.Length > 5), ]
```

### Creating new variables

We can create new variables using the assignment operators. To create a variable `x` that contains the results of `2+2`, simply do this:

```{r}
x = 2 + 2
```

And to see the value of `x`, simply type `x` in the console. 

With a data frame, we might want to create a new variable for each observation. In the iris dataset, there are the measurements of both width and length of each flowers petal. We can approximate the area of each petal as an ellipse, using the length as a major axis and the width as the minor axis. The area is then given by 

$$A = \pi \times \mbox{length} \times \mbox{width}$$

In R, we would calculate this as:

```{r results='hide'}
pi * iris$Petal.Length * iris$Petal.Width
```

We can create a new variable `Petal.area` to store this using the assignment operator:

```{r}
Petal.Area = pi * iris$Petal.Length * iris$Petal.Width
```

More usefully, we can store this in the `iris` data frame using the `$` syntax:

```{r}
iris$Petal.Area = pi * iris$Petal.Length * iris$Petal.Width
str(iris)
```


### Writing data out

R can export data in a number of different formats, including csv files. Here, we'll create a new file using the `iris` data frame, but with the new column of petal areas included:

```{r}
write.csv(iris, "iris2.csv", row.names = FALSE)
```

In your working directory, you should now see this new file appear. By default, R adds a row index to each line of the file, the `row.names` argument simply turns this off. 

## Functions in R
Functions typically are comprised of the name of the function (`sqrt` for taking square roots) and a set of parentheses. The parentheses are used to pass data to the function as well as setting parameters to change the behavior of the function.
```{r}
sqrt(5)
```

Note that we can use the assignment operator to save the output from a function, allowing you to use this in subsequent functions and analyses. 
```{r}
y <- sqrt(5)
round(y)
```
To save time and code, functions can be combined:
```{r}
round(sqrt(5))
```

The `seq()` function produces a series of numbers on a regular step. By default, it require 3 parameters, the starting number, the ending number and the step.
```{r}
seq(from=0,to=20,by=2)
```
If you include the parameter names, as in this example, the order does not matter. The parameter names can be omitted if you keep to the specified order of parameters. So `seq(0,20,2)` will give you the equivalent results.

To find out what these parameters are, what they are called and what values they take, use the `help()` function, e.g. `help(seq)`. This will open a window with the help file for that function. If you do not know the name of a function, there is a search function `help.search()`, or use the help browser `help.start()`, browse to packages or use the search engine.

### Univariate statistics
Now create two new vectors in R containing the list of sepal lengths and the list of species names. Note the use of the assignment operator `<-`. You can also use the equal sign  (`=`) here and elsewhere in these examples.
```{r}
sl <- iris$Sepal.Length
sp <- iris$Species
```

R has a large number of inbuilt functions. This section is designed to simply introduce you to the some basic functions for describing data:

Functions to describe the central tendency:
```{r}
mean(sl) ## Mean
median(sl) ## Median
sd(sl) ## Standard deviation
min(sl) ## Minimum
max(sl) ## Maximum
quantile(sl) ## Percentiles
```
Note that `quantile()` takes a parameter that allows you to choose the quantile to be calculated, e.g. `quantile(sl, c(0.1,0.9))`, will calculate the 10th and 90th percentile. Try adapting this to calculate the 25th and 75th percentile.

Some other useful functions:
```{r results='hide'}
sum(sl) ## Sum of all values
summary(sl) ## Summary statistics
```

Some specific functions for categorical data
```{r results='hide'}
levels(sp) ## List of categories
table(sp) ## Number of observations in each category
```
As R is object oriented, functions will adapt to different data types
```{r results='hide'}
summary(sl) ## Summary of numeric vector
summary(sp) ## Summary of categorical vector (factors)
summary(iris) ## Summary of data frame
```

## Quitting R
When you are finished with R, exit by typing `q()` in the console (or going to [File] $>$ [Quit R Studio]). You will be asked if you want to save your workspace. This is generally a good idea, as this will create a file containing all your current data (".RData"), and the history (".Rhistory") of the commands you have used. If you restart R in the same directory, by clicking on an R script file, the workspace will be loaded automatically. If it doesn't, you can load this by changing to the the correct working directory and typing:

```{r eval=FALSE}
load(".RData")
```

## Basic plotting in R

We'll now look quickly at the basic plotting functions in R. R has a wide range of plotting types, and we will look at some more complex methods later in this class. For now, we will concentrate on the basic plotting function (`plot()`) and how to simply modify this.

Restart R Studio (or R) and make sure you set the working directory to where your files are located. Now load the Iris datasets:

```{r}
iris = read.csv("iris.csv")
```

### Enumerative plots
The simplest type of plot is an index plot, which simply plots values in the order they are recorded in the input vector. These are useful for examining the basic data structure and identifying errors and outliers. `plot` is a generic plotting command and will adapt to different data types. The parameter `type='p'` gives the plot type, here using points. Other options are `'l'` for lines, `'h'` for histogram lines, `'s'` for a stepped plot and `'b'` for both line and points. See `help(plot)` for more options and other parameters. 

```{r fig.keep='high'}
plot(iris$Sepal.Length, type='p')
```

### Summary plots 
Summary plots attempt to describe the distribution of the data, giving some ideas about which values are most common and which are most rare. Histograms are commonly used for this method, values are 'binned' into a set of classes, and the histogram represents the frequency of occurrences in that bin. Bins are defined with the `breaks` parameter, which may be set to a constant number in which case the data range is split into that many bins, or as a sequence of numbers defining the intervals between bins. In this latter case, we can make use of the `seq()` function from earlier. 

```{r fig.keep='none'}
hist(iris$Sepal.Length, breaks=20)
hist(iris$Sepal.Length, breaks=seq(4,8,0.25))
```
An alternative to histograms are boxplots, which show information about the data quartiles.
Here the box represents the interquartile data (25-75\% of the data), the thick bar is the median, and the 'whiskers' show the data range.

```{r fig.keep='none'}
boxplot(iris$Sepal.Length)
```

### Bivariate plots
Bivariate plots are designed to show the relationship between two variables, and how this may vary. The simplest form is the scatter plot. We use the `plot()` function again, but now we give it two variables (x and y). 
```{r fig.keep='none'}
plot(iris$Petal.Length,iris$Petal.Width)
```
As we know that these values come from three difference species, we can use this knowledge
to add extra information to the plot, by using the `col` parameter. Note that even though the species names are character strings in the input file, R converts these to classes (1-3), and then uses these for the colors. We can also change the symbol type using the `pch` parameter.

```{r}
plot(iris$Petal.Length,iris$Petal.Width,
     col=iris$Species, pch=4)
```

Let's clean up this plot a little by specifying the axis labels and a title:

```{r eval=FALSE}
plot(iris$Petal.Length,iris$Petal.Width,
     col=iris$Species, pch=4, 
     xlab="Petal length (cm)", ylab="Petal width (cm)",
     main="Fisher's Iris Data")
```

We can also add a legend to our plot to explain the different colors and symbols. Unfortunately, R makes you do all the work for this, using the `legend()` function. Here, we add a legend to the top left of the plot, giving the labels for each color and the color used:

```{r eval=FALSE}
legend("topleft",legend=c("Setosa","Versicolor","Virginica"),
       col=c(1,2,3), pch=4)
```

```{r eval=FALSE}
plot(iris$Petal.Length,iris$Petal.Width,
     col=iris$Species, pch=4, 
     xlab="Petal length (cm)", ylab="Petal width (cm)",
     main="Fisher's Iris Data")
legend("topleft",legend=levels(iris$Species),
       col=c(1,2,3), pch=4)
```

## Plotting with **ggplot2**

We'll finish this lab by exploring an add-on package to R. Add-on packages extend R's base functionality in a number of different ways including analysis, data management and visualization. There are a large number available (over 15,000 at the time of writing), and are organized into categories [here][tvID]. A full list of available packages can be found [here][packID]. 

Some packages are installed by default (you can check what is installed on your computer by clicking on the 'Packages' tab in the lower right hand corner of RStudio), while others need to be installed. To install a package in R, simply type the following into the console, replacing `nameofpackage` with the package you want to install:

```{r eval=FALSE}
install.packages("nameofpackage")
```

We will use **ggplot2**, a package designed to improve on R's base graphic functions. Start by installing this as follows:

```{r eval=FALSE}
install.packages("ggplot2")
```

Add-on packages only need to be installed once, but need to be *loaded* each time you start R, to make them avaialble in your current session. You can load a package by typing:

```{r}
library(ggplot2)
```

**ggplot2** works in a slightly different way to base R. We start by creating a `ggplot` object that contains the data frame (`iris`) and the aesthetic, which defines the variables to use in plot. We'll start with a histogram of petal length, which only requires one axis. 


```{r}
p1 = ggplot(iris, aes(x = Petal.Length))
```

Next, we add a 'geometry' to this axis, which will define how the variable is plotted. Here, we add a histogram:

```{r}
p1 + geom_histogram()
```

We can improve on this in a couple of ways. First we add a second variable (the species name) to the aesthetic to make histograms by species, add a small amount of transparency (`alpha`), and alter the position so that the histogram overlap (the default is to stack the histograms). Note that here we don't save the initial `ggplot` object, but add the geometry directly:

```{r}
ggplot(iris, aes(x = Petal.Length, fill = Species)) + 
  geom_histogram(binwidth = 0.25, alpha = 0.75, position = 'identity')
```

Note that **ggplot2** automatically adds a legend for the color palette. Next, let's make a boxplot. This requires two variables in the aesthetic, the groups for the x-axis and the variable for the y-axis:

```{r}
ggplot(iris, aes(x = Species, y = Petal.Length)) + geom_boxplot()
```

We can make a scatter plot by including two numerical variables in the aesthetic and a point geometry:

```{r}
ggplot(iris, aes(x = Petal.Length, y = Petal.Width, col = Species)) + 
  geom_point()
```

And we can add a further geometry (`geom_smooth()`) to add a best fit line to each group:
```{r}
ggplot(iris, aes(x = Petal.Length, y = Petal.Width, col = Species)) + 
  geom_point() + geom_smooth(method = "lm")
```

Note that we can continue to add other geometries and plot components to the figure. The following code adds a plot title, x and y axis labels and changes the plot theme, which controls the overall layout of the figure:

```{r}
ggplot(iris, aes(x = Petal.Length, y = Petal.Width, col = Species)) + 
  geom_point() + geom_smooth(method = "lm") + ggtitle("Fisher's Iris Dataset") +
  scale_x_continuous("Petal length (cm)") + scale_y_continuous("Petal width (cm)") +
  theme_classic()
```

The last thing we'll introduce here are *facets*. These take a single figure and break it up into small multiples based on some grouping variable, useful for exploring complex, structured datasets. We'll use facets here to split this scatterplot into three panels, one per species. This is not particularly useful here, but we will use this function a lot later in the semester:

```{r}
ggplot(iris, aes(x = Petal.Length, y = Petal.Width)) + 
  geom_point() + geom_smooth(method = "lm") + facet_wrap(~Species)
```

[cranid]: https://cran.r-project.org
[rstudioid]: https://www.rstudio.com
[tvID]: http://cran.r-project.org/web/views/
[packID]: https://cran.r-project.org/web/packages/
